package com.calvaryventura.broadcast.uiwidgets;import javax.swing.BorderFactory;import javax.swing.JComponent;import javax.swing.JFrame;import java.awt.BasicStroke;import java.awt.Color;import java.awt.Font;import java.awt.Graphics;import java.awt.Graphics2D;import java.awt.Point;import java.awt.RenderingHints;import java.awt.Toolkit;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import java.awt.geom.Ellipse2D;import java.awt.geom.Rectangle2D;import java.util.ArrayList;import java.util.List;import java.util.function.BiConsumer;/** * Custom UI widget for showing progress for the frequency and overall mission sweeps. * Both frequency and mission are displayed in the same plot. */public class DirectionalTouchUi extends JComponent{    private static final Color DISPLAY_MESSAGE_COLOR = Color.GREEN;    private static final Color BACKGROUND_COLOR = Color.GRAY.darker();    private static final Color LINE_COLOR = new Color(150, 255, 150);    private static final Color CENTER_DOT_COLOR = new Color(150, 150, 255);    private static final Color CENTER_DOT_MOVING_COLOR = new Color(255, 190, 0);    private static final Double centerCirclePercentCoverage = 0.2;    private static final int LINE_WIDTH_PIX = 1;    private final List<BiConsumer<Double, Double>> xyChangedConsumers = new ArrayList<>();    private String displayMessage = null;    private Point mouseDragPt;    private double circleSizePix;    /**     * Creates the progress indicator and sets up general UI component properties.     */    public DirectionalTouchUi()    {        this.setLayout(null);        this.setOpaque(false);        this.setBackground(BACKGROUND_COLOR);        this.setBorder(BorderFactory.createRaisedBevelBorder());        this.addMouseListener(createMouseEventHandler());        this.addMouseMotionListener(createMouseEventHandler());    }    /**     * @param xyChangedConsumer used to send the latest X/Y (i.e. pan/tilt) information back to the parent     */    public void addXYOutputConsumer(BiConsumer<Double, Double> xyChangedConsumer)    {        this.xyChangedConsumers.add(xyChangedConsumer);    }    /**     * Writes a message to the upper half of the UI panel.     *     * @param msg the text to display (NULL to clear)     */    public void setDisplayMessage(String msg)    {        this.displayMessage = msg;        this.repaint();    }    /**     * This class extends a JComponent. Override the UI component's 'paintComponent' method     * which allows us to insert out own custom code for drawing graphics onto the     * panel. Note that using this requires setting a 'null' layout for the panel.     * {@inheritDoc}     */    @Override    public void paintComponent(Graphics g)    {        // draw the solid background        super.paintComponent(g);        final Graphics2D g2d = (Graphics2D) g;        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); // TODO        g2d.setColor(BACKGROUND_COLOR);        g2d.fillRect(0, 0, getWidth(), getHeight());        // draw the thin lines        g2d.setColor(LINE_COLOR);        g2d.setStroke(new BasicStroke(LINE_WIDTH_PIX));        g2d.drawLine(0, 0, getWidth(), getHeight());        g2d.drawLine(getWidth(), 0, 0, getHeight());        g2d.drawLine(getWidth() / 2, 0, getWidth() / 2, getHeight());        g2d.drawLine(0, getHeight() / 2, getWidth(), getHeight() / 2);        // draw the ellipse line        this.circleSizePix = centerCirclePercentCoverage * Math.min(getWidth(), getHeight());        g2d.draw(new Ellipse2D.Double(                (float) getWidth() / 2 - circleSizePix / 2,                (float) getHeight() / 2 - circleSizePix / 2,                circleSizePix,                circleSizePix));        // draw the center ellipse fill        g2d.setColor(this.mouseDragPt == null ? CENTER_DOT_COLOR : CENTER_DOT_COLOR.darker());        g2d.fill(new Ellipse2D.Double(                (float) getWidth() / 2 - circleSizePix / 2 + LINE_WIDTH_PIX,                (float) getHeight() / 2 - circleSizePix / 2 + LINE_WIDTH_PIX,                circleSizePix - 2 * LINE_WIDTH_PIX,                circleSizePix - 2 * LINE_WIDTH_PIX));        // draw the moving ellipse fill        if (this.mouseDragPt != null)        {            g2d.setColor(CENTER_DOT_MOVING_COLOR);            g2d.fill(new Ellipse2D.Double(                    (float) this.mouseDragPt.x - circleSizePix / 2 + LINE_WIDTH_PIX,                    (float) this.mouseDragPt.y - circleSizePix / 2 + LINE_WIDTH_PIX,                    circleSizePix - 2 * LINE_WIDTH_PIX,                    circleSizePix - 2 * LINE_WIDTH_PIX));        }        // draw text        if (this.displayMessage != null)        {            final Font font = new Font("Arial", Font.BOLD, 20);            final Rectangle2D rect = font.getStringBounds(this.displayMessage, g2d.getFontRenderContext());            final int blockStartX = (int) (getWidth() / 2 - rect.getWidth() / 2);            final int blockStartY = (int) (getHeight() / 4 + rect.getHeight() / 2 - 3);            g2d.setColor(DISPLAY_MESSAGE_COLOR);            g2d.setFont(font);            g2d.drawString(this.displayMessage, blockStartX, blockStartY);        }        // required for Linux/Apple computers        Toolkit.getDefaultToolkit().sync();        g.dispose();    }    /**     * Sets up a simple mouse press and drag action, which updates the global     * variable 'mouseDragPt' when the user moves the mouse outside the center zone.     *     * @return a mouse handler interface ready to be used by this panel     */    private MouseAdapter createMouseEventHandler()    {        return new MouseAdapter() {            /**             * Takes in the mouse location and sets the global 'mouseDragPt' property.             *             * @param p location of the mouse press or drag             */            private void updateMouseMovePoint(Point p) {                final double x = Math.min(Math.max(p.getX(), circleSizePix / 2), getWidth() - circleSizePix / 2);                final double y = Math.min(Math.max(p.getY(), circleSizePix / 2), getHeight() - circleSizePix / 2);                final double xPercent = 2 * (x - (double) getWidth() / 2) / (getWidth() - circleSizePix);   // multiply by 2 to get percentages                final double yPercent = 2 * (y - (double) getHeight() / 2) / (getHeight() - circleSizePix); // 0-100% away from the center location                final boolean movementInX = Math.abs(x - (double) getWidth() / 2) > circleSizePix / 4;                final boolean movementInY = Math.abs(y - (double) getHeight() / 2) > circleSizePix / 4;                xyChangedConsumers.forEach(c -> c.accept(movementInX ? xPercent : 0, movementInY ? -yPercent : 0)); // negate Y since we want UP to be POSITIVE percentage                if (movementInX || movementInY) {                    mouseDragPt = new Point((int) x, (int) y);                } else {                    mouseDragPt = null;                }                repaint();            }            @Override            public void mouseReleased(MouseEvent e) {                mouseDragPt = null;                xyChangedConsumers.forEach(c -> c.accept(0.0, 0.0));                repaint();            }            @Override            public void mousePressed(MouseEvent e) {                updateMouseMovePoint(e.getPoint());            }            @Override            public void mouseDragged(MouseEvent e) {                updateMouseMovePoint(e.getPoint());            }        };    }    /**     * @param args no arguments     */    public static void main(String[] args)    {        final DirectionalTouchUi uut = new DirectionalTouchUi();        final JFrame f = new JFrame("Directional touch/swipe panel test");        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);        f.add(uut);        f.setSize(300, 300);        f.setLocationRelativeTo(null);        f.setVisible(true);        // print out whenever the consumer fires        uut.addXYOutputConsumer((pan, tilt) ->                System.out.printf("PAN = %.0f%%, TILT = %.0f%%\n", pan * 100, tilt * 100));        // draw text        uut.setDisplayMessage("NOT CONNECTED");    }}